/* -*- mode: c++ -*-
 * Kaleidoscope-Papageno -- Papageno features for Kaleidoscope
 * Copyright (C) 2017 noseglasses <shinynoseglasses@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#define KALEIDOSCOPE_PAPAGENO_POSTPONE_INITIALIZATION
#include <Kaleidoscope-Papageno.h>
#include <kaleidoscope/hid.h>

extern "C" {
#include "detail/ppg_pattern_matching_detail.h"
#include "detail/ppg_active_tokens_detail.h"
#include "detail/ppg_context_detail.h"
}

#define PPG_KLS_LOGGING_ENABLED

#ifdef PPG_KLS_LOGGING_ENABLED

#include <iostream>

#define PPG_KLS_LOG(TOKEN) \
      std::cout << TOKEN;
#define PPG_KLS_LOGN(TOKEN) \
      std::cout << TOKEN << std::endl;
   
#else
#define PPG_KLS_LOG(TOKEN)
#define PPG_KLS_LOGN(TOKEN)
#endif

extern "C" {
   
   // The initialization method for the global papageno context
   // is define in the code that is generated by the Glockenspiel
   // compiler.
   //
   __attribute__((weak)) 
   void papageno_initialize_context() {}
}

kaleidoscope::papageno::Papageno Papageno;

namespace kaleidoscope {
namespace papageno {
   
static uint8_t eventsFlushed_ = 0;
static bool eventHandlerDisabled = false;

struct TemporarilyDisableEventHandler
{
   TemporarilyDisableEventHandler() { eventHandlerDisabled = true; }
   ~TemporarilyDisableEventHandler() { eventHandlerDisabled = false; }
};

static bool loopHookDisabled = false;

struct TemporarilyDisableLoopHook
{
   TemporarilyDisableLoopHook() { loopHookDisabled = true; }
   ~TemporarilyDisableLoopHook() { loopHookDisabled = false; }
};

enum PapagenoState {
   PapagenoInitialized,
   PapagenoInProgress,
   PapagenoTimeout,
   PapagenoAborted,
   PapagenoMatchFailed
};

static uint8_t state = PapagenoInitialized;

static bool failureOccurred = false;

static uint8_t loopCycleCount = 0;

static int16_t lastEventGroupId = -1;

inline
static uint8_t getKeystate(bool pressed)
{
   return ((pressed) ? (IS_PRESSED) : (WAS_PRESSED));
}

static void finishLoopCycle(uint8_t groupId)
{
   if(lastEventGroupId == groupId) { 
      
      PPG_KLS_LOGN("Still same cycle " << (int)groupId << ", no loop hook processing")
      return; 
   }
      
   PPG_KLS_LOGN("New cycle " << (int)groupId << ", processing loop hooks")
 
   Kaleidoscope.processLoopHooks();
//    Kaleidoscope.loop();
   
   lastEventGroupId = groupId;
}

static void finishCurrentLoopCycle(void) {

   // The group id codes the loop cycle
   //
   uint8_t curGroupId 
      = kaleidoscope::papageno::loopCycleCount % 0xFF;
   
   // Flushed events must be processed in the same way as 
   // they arrived. It is possible that the abort of pattern
   // matching caused flushing of events. If the last flushed
   // event came from another loop cycle, we have ensure to
   // correctly flush a report.
   //
   finishLoopCycle(curGroupId);
}

static void flushEvent(PPG_Event *event)
{
   int16_t highest_keypos = highestKeyposInputId();

   uint8_t keyState = kaleidoscope::papageno::getKeystate(
      event->flags & PPG_Event_Active);
   
   if(event->flags & PPG_Event_Active) {
      // Flushed events must be processed in the same way as 
      // they arrived. Those events that arrived within the same
      // Kaleidoscope-loop cycle. The loop cycle (modulo 0xFF)
      // is used as event group id.
      //
      finishLoopCycle(event->groupId);
   }
      
   // Note: Input-IDs are assigned contiguously
   //
   //       Input ids assigned to keypos-inputs are {0..PPG_Highest_Keypos_Input}
   //       
   //       Input ids assigned to keycode-inputs are {PPG_Highest_Keypos_Input + 1..PPG_Highest_Keycode_Input}
   
   TemporarilyDisableEventHandler tdh;
   
   if(event->input > highest_keypos) {
      
      // Map the input to a range starting from zero to be suitable
      // for lookup in the ppg_kls_keycode_lookup array
      //
      Key key = ppg_kls_keycode_lookup[event->input - highest_keypos - 1];
      
      PPG_KLS_LOG("flushing event by keycode ")
      PPG_KLS_LOG(key.raw)
      PPG_KLS_LOGN("")
              
      // Note: Setting UNKNOWN_KEYSWITCH_LOCATION will skip keymap lookup
      //
      handleKeyswitchEvent(key, UNKNOWN_KEYSWITCH_LOCATION, keyState);
   }
   else {
      PPG_KLS_LOG("event ")
      PPG_KLS_LOG((uint16_t)event)
      PPG_KLS_LOG(", input ")
      PPG_KLS_LOG((int)event->input)
      PPG_KLS_LOG(", group ")
      PPG_KLS_LOGN((int)event->groupId)
      
      PPG_KLS_LOG("flushing event by keypos (")
      PPG_KLS_LOG((int)ppg_kls_keypos_lookup[event->input].row)
      PPG_KLS_LOG(", ")
      PPG_KLS_LOG((int)ppg_kls_keypos_lookup[event->input].col)
      PPG_KLS_LOG("), keystate = ")
      PPG_KLS_LOG((int)keyState)
      PPG_KLS_LOGN("")
      
      handleKeyswitchEvent(Key_NoKey, 
                           ppg_kls_keypos_lookup[event->input].row,
                           ppg_kls_keypos_lookup[event->input].col,
                           keyState);
   } 
   
//    if(!(event->flags & PPG_Event_Active)) {
//       // Flushed events must be processed in the same way as 
//       // they arrived. Those events that arrived within the same
//       // Kaleidoscope-loop cycle. The loop cycle (modulo 0xFF)
//       // is used as event group id.
//       //
//       finishLoopCycle(event->groupId);
//    }
}

static void processEventCallback(   
                              PPG_Event *event,
                              void *)
{
   // Ignore events that were considered, i.e. swallowed by Papageno
   //
   if(event->flags & PPG_Event_Considered) {

      return; 
   }
   
   PPG_LOG("processEventCallback\n")
   
   flushEvent(event);

   ++papageno::eventsFlushed_;
}

static void flushEvents()
{  
   PPG_LOG("Flushing events\n")
   
   /*uint8_t nEventsProcessed 
      = */ppg_event_buffer_iterate(
         processEventCallback,
         NULL
      );
      
//    if(nEventsProcessed) {
//       kaleidoscope::hid::sendKeyboardReport();
//    }
}

void time(PPG_Time *time)
{
   *time = static_cast<uint16_t>(millis());
}

void timeDifference(PPG_Time time1, PPG_Time time2, PPG_Time *delta)
{
   uint16_t *delta_t = (uint16_t *)delta;
   
   *delta_t = (uint16_t)time2 - (uint16_t)time1; 
}

int8_t timeComparison(
                        PPG_Time time1,
                        PPG_Time time2)
{
   if((uint16_t)time1 > (uint16_t)time2) {
      return 1;
   }
   else if((uint16_t)time1 == (uint16_t)time2) {
      return 0;
   }
    
   return -1;
}

static void signalCallback(PPG_Signal_Id signal_id, void *)
{
   switch(signal_id) {
      case PPG_On_Abort:
         PPG_KLS_LOGN("Abort")
         papageno::state = PapagenoAborted;
         failureOccurred = true;
         papageno::flushEvents();
         break;
      case PPG_On_Timeout:
         PPG_KLS_LOGN("Timeout")
         papageno::state = PapagenoTimeout;
         failureOccurred = true;
         papageno::flushEvents();
         break;
      case PPG_On_Match_Failed:
         PPG_KLS_LOGN("Match failed")
         // Let 
         //papageno::state = PapagenoMatchFailed;
         failureOccurred = true;
         // Events are flushed automatically
         break;      
      case PPG_On_Flush_Events:
         PPG_KLS_LOGN("Flush events")
         papageno::flushEvents();
         break;
      case PPG_On_Initialization:
         PPG_KLS_LOGN("On initialization")
         papageno::state = PapagenoInitialized;
         break;
      case PPG_Before_Action:
         PPG_KLS_LOGN("Before action")
//          finishCurrentLoopCycle();
         break;
      default:
         return;
   }
} 

static Key eventHandlerHook(Key keycode, byte row, byte col, uint8_t key_state)
{ 
//    if((row == 2) && (col == 8)) {
//       PPG_KLS_LOGN("(2, 8) keystate = " << (int)key_state)
//    }
   
   // When flushing events, this event handler must 
   // be disabled as the events are meant to be handled 
   // by the rest of Kaleidoscope.
   //
   if(eventHandlerDisabled) {
      return keycode;
   }
   
   if(key_state == 0) { return keycode; }
   
   // Don't react on injected keys
   //
   if(key_state & INJECTED) { return keycode; }
   
   PPG_KLS_LOG("eventHandlerHook")
   PPG_KLS_LOG(", row ")
   PPG_KLS_LOG((int)row)
   PPG_KLS_LOG(", col ")
   PPG_KLS_LOG((int)col)
   PPG_KLS_LOG(", keycode ")
   PPG_KLS_LOG((int)keycode.raw)
   PPG_KLS_LOG(", key_state ")
   PPG_KLS_LOG((int)key_state)
   PPG_KLS_LOGN("")
   
//    if(key_state & INJECTED) { abort(); }
   
   TemporarilyDisableEventHandler tdh;
   
   PPG_Count flags = PPG_Event_Flags_Empty;
   bool keyStateChanged = true;
   if (keyToggledOn(key_state)) {
      flags = PPG_Event_Active;
   }
   else if(!keyToggledOff(key_state)) {

      // If the key remains pressed, we just ignore it
      //
      keyStateChanged = false;
   }
   
   #define PPG_KLS_INPUT_CHECK_A \
         inputIdFromKeypos(row, col)

   #define PPG_KLS_INPUT_CHECK_B \
         inputIdFromKeycode(keycode)
         
   // The default behavior is to first check it an 
   // input is defined through the keypos of a key.
   // If not then we check the assigned keycode.
   //
   // By defining PPG_KLS_REVERSE_KEYPOS_TO_KEYCODE_PRECEDENCE
   // this order can be reversed.
   //
   #ifndef PPG_KLS_REVERSE_KEYPOS_TO_KEYCODE_PRECEDENCE
      #define PPG_KLS_INPUT_CHECK_1 PPG_KLS_INPUT_CHECK_A
      #define PPG_KLS_INPUT_CHECK_2 PPG_KLS_INPUT_CHECK_B
   #else // PPG_KLS_REVERSE_KEYPOS_TO_KEYCODE_PRECEDENCE
      #define PPG_KLS_INPUT_CHECK_1 PPG_KLS_INPUT_CHECK_B
      #define PPG_KLS_INPUT_CHECK_2 PPG_KLS_INPUT_CHECK_A
   #endif // PPG_KLS_REVERSE_KEYPOS_TO_KEYCODE_PRECEDENCE
         
   uint8_t input = PPG_KLS_INPUT_CHECK_1;
   
   if(input == PPG_KLS_Not_An_Input) { 
      
      input = PPG_KLS_INPUT_CHECK_2;
      
      if(input == PPG_KLS_Not_An_Input) { 
         
//          PPG_LOG("not an input\n");
         
         // Only if another (unrelated) key was pressed we abort.
         //
         if(flags == PPG_Event_Active) {

            PPG_KLS_LOGN("before: keycode " << keycode.raw
               << ", layerState " << Layer.getLayerState())
            
            papageno::eventsFlushed_ = 0;
            
            // Whenever a key occurs that is not an input,
            // we immediately abort pattern matching
            //
            ppg_global_abort_pattern_matching();
            
            if(papageno::eventsFlushed_) {

               finishCurrentLoopCycle();
               
               // Note: The current layer might have been changed during abort
               //       of pattern matching as, e.g. a tap dance might have
               //       toggled a layer switch. 
               
               // Update the live composite keymap for the current key
               //
               Layer.updateLiveCompositeKeymap(row, col);
               
               // To be on the safe side, we lookup on the current layer.
               //
               keycode = Layer.lookupOnActiveLayer(row, col);
            }
            
            PPG_KLS_LOGN("Events flushed: " << (int)papageno::eventsFlushed_)
            
            PPG_KLS_LOGN("after: keycode " << keycode.raw
               << ", layerState " << Layer.getLayerState())
         }
         
//          Serial.print("Skipping keycode ");
//          Serial.println(keycode.raw);
//          Serial.flush();
         
         // Let Kaleidoscope process the key in a regular way
         //
         return keycode;
      }
   }
// else {
//    uprintf("input %u, row %u, col %u\n", input, record->event.key.row, 
//                         record->event.key.col);
//   }

//    PPG_KLS_LOG("input ")
//    PPG_KLS_LOG((int)input)
//    PPG_KLS_LOG(", row ")
//    PPG_KLS_LOG((int)row)
//    PPG_KLS_LOG(", col ")
//    PPG_KLS_LOG((int)col)
//    PPG_KLS_LOG(", keycode ")
//    PPG_KLS_LOG((int)keycode.raw)
//    PPG_KLS_LOG(", key_state ")
//    PPG_KLS_LOG((int)key_state)
//    PPG_KLS_LOGN("")
   
//    // Check it the pattern matching engine is in initial state
//    //
//    if(ppg_context->current_token == NULL) {
//       papageno::state = PapagenoInitialized;
//    }
   
   if(!keyStateChanged) {
      
      PPG_KLS_LOGN("papageno::state = " << (int)papageno::state)
            
      // The key is obviously an input. If there are nevertheless no events in the buffer this means that a previous match with the key failed.
      // In such a case, we pass it back to Kaleidoscope immediately.
      //
      if(failureOccurred
         && !ppg_pattern_matching_in_progress()
      ) {
         PPG_KLS_LOG("Bad engine state => passing keycode\n")
         return keycode;
      }
      
      // Just ignore keys that represent inputs that already became 
      // activated and that are active but whose state did not change.
      //
      return Key_NoKey;
   }
   
   // Clear failure state
   //
   failureOccurred = false;
   
   // Non activation events are ignored if there are no active tokens
   // and no queued events.
   //
   if((ppg_event_buffer_size() == 0) && (ppg_active_tokens_get_size() == 0)
      && (flags == PPG_Event_Flags_Empty)) {
      return keycode;
   }
 
//    std::cout << "eventHandlerHook: keycode.raw = " << (int)keycode.raw 
//       << ", row = " << (int)row << ", col = " << (int)col 
//       << ", key_state = " << (int)key_state << std::endl;
      
   PPG_Event p_event = {
      .input = input,
      .time = (PPG_Time)millis(),
      .flags = flags,
      
      // The group id is used to code the loop count a event occured
      // within
      //
      .groupId = kaleidoscope::papageno::loopCycleCount % 0xFF
   };
   
   uint8_t cur_layer = Layer.top();
   
   ppg_global_set_layer(cur_layer);
   
   papageno::state = PapagenoInProgress;
   
   PPG_KLS_LOGN("Feeding event")
   
   ppg_event_process(&p_event);
   
   return Key_NoKey;
}

static void loopHook(bool is_post_clear)
{
   // Protect the loop hook against infinite recursive loops
   
   if(loopHookDisabled) { return; }
   
   TemporarilyDisableLoopHook tdlh;
   
   if(!is_post_clear) {
      
      ++kaleidoscope::papageno::loopCycleCount;
      
      // As timeout might cause events e.g. when a tap-dance is 
      // activated, we have to make sure that we do not run into a loop
      // here.
      //
      {
         TemporarilyDisableEventHandler tdh;
//       PPG_KLS_LOGN("Timeout check")
         ppg_timeout_check();
      }
      
//       PPG_KLS_LOG("active tokens")
      PPG_KLS_LOGN("# active tokens: " << (int)PPG_GAT.n_tokens)
      ppg_active_tokens_repeat_actions();
   }
}

void 
   Papageno
      ::begin() 
{
   // Initialize the static global pattern matching tree
   //
    papageno_initialize_context();
//    
   this->init();
   
   Kaleidoscope.useEventHandlerHook(
         kaleidoscope::papageno::eventHandlerHook);
   
   Kaleidoscope.useLoopHook(
         kaleidoscope::papageno::loopHook);
}

void 
   Papageno
      ::init()
{
   ppg_global_set_default_event_processor(
      (PPG_Event_Processor_Fun)kaleidoscope::papageno::processEventCallback);

   ppg_global_set_signal_callback(
      (PPG_Signal_Callback) {
            .func = (PPG_Signal_Callback_Fun)kaleidoscope::papageno::signalCallback,
            .user_data = NULL
      }
   );

   ppg_global_set_time_manager(
      (PPG_Time_Manager) {
         .time
            = (PPG_Time_Fun)kaleidoscope::papageno::time,
         .time_difference
            = (PPG_Time_Difference_Fun)kaleidoscope::papageno::timeDifference,
         .compare_times
            = (PPG_Time_Comparison_Fun)kaleidoscope::papageno::timeComparison
      }
   );
}

void  
   Papageno
      ::processKeycode(PPG_Count activation_flags, void *user_data)
{   
   Key key 
      = (Key){ .raw 
            = reinterpret_cast<uint16_t>(user_data)};
      
   uint8_t keyState = kaleidoscope::papageno::getKeystate(
                  activation_flags & PPG_Action_Activation_Flags_Active);
   
   PPG_KLS_LOG("keycode action. keycode ")
   PPG_KLS_LOG((int)key.raw)
   PPG_KLS_LOG(", keyState ")
   PPG_KLS_LOG((int)keyState)
   PPG_KLS_LOGN("")
   
   // Note: Setting UNKNOWN_KEYSWITCH_LOCATION will skip keymap lookup
   //
   {
      TemporarilyDisableEventHandler tdh;
      handleKeyswitchEvent(key, UNKNOWN_KEYSWITCH_LOCATION, keyState);
   }
}

void processKeypos(PPG_Count activation_flags, void *user_data)
{
   uint16_t raw = (uint16_t)user_data;
   uint8_t row = raw >> 8;
   uint8_t col = raw & 0x00FF;
         
   uint8_t keyState = kaleidoscope::papageno::getKeystate(
                  activation_flags & PPG_Action_Activation_Flags_Active);
   
   PPG_KLS_LOG("keypos action. row ")
   PPG_KLS_LOG((int)row)
   PPG_KLS_LOG(", col ")
   PPG_KLS_LOG((int)col)
   PPG_KLS_LOG(", keyState ")
   PPG_KLS_LOG((int)keyState)
   PPG_KLS_LOGN("")
   
   // Note: Setting UNKNOWN_KEYSWITCH_LOCATION will skip keymap lookup
   //
   {
      TemporarilyDisableEventHandler tdh;
      handleKeyswitchEvent(Key_NoKey, row, col, keyState);
   }
}

} // end namespace papageno
} // end namepace kaleidoscope
